import numpy as np
import numba as nb
from functools import partial
from .overrides import pi, exp, sqrt, sin, cos, sinh, cosh, arcsin

jit = partial(nb.jit, nopython=True, nogil=True)
vectorize = nb.vectorize  # partial(nb.vectorize, nopython=True)

_x_kr21 = (-9.956571630258080807355272806890028e-01, -9.739065285171717200779640120844521e-01, -9.301574913557082260012071800595083e-01, -8.650633666889845107320966884234930e-01, -7.808177265864168970637175783450424e-01, -6.794095682990244062343273651148736e-01, -5.627571346686046833390000992726941e-01, -4.333953941292471907992659431657842e-01, -2.943928627014601981311266031038656e-01, -1.488743389816312108848260011297200e-01, 0.0, 1.488743389816312108848260011297200e-01, 2.943928627014601981311266031038656e-01, 4.333953941292471907992659431657842e-01, 5.627571346686046833390000992726941e-01, 6.794095682990244062343273651148736e-01, 7.808177265864168970637175783450424e-01, 8.650633666889845107320966884234930e-01, 9.301574913557082260012071800595083e-01, 9.739065285171717200779640120844521e-01, 9.956571630258080807355272806890028e-01)

_w_kr21 = (1.169463886737187427806439606219205e-02, 3.255816230796472747881897245938976e-02, 5.475589657435199603138130024458018e-02, 7.503967481091995276704314091619001e-02, 9.312545458369760553506546508336634e-02, 1.093871588022976418992105903258050e-01, 1.234919762620658510779581098310742e-01, 1.347092173114733259280540017717068e-01, 1.427759385770600807970942731387171e-01, 1.477391049013384913748415159720680e-01, 1.494455540029169056649364683898212e-01, 1.477391049013384913748415159720680e-01, 1.427759385770600807970942731387171e-01, 1.347092173114733259280540017717068e-01, 1.234919762620658510779581098310742e-01, 1.093871588022976418992105903258050e-01, 9.312545458369760553506546508336634e-02, 7.503967481091995276704314091619001e-02, 5.475589657435199603138130024458018e-02, 3.255816230796472747881897245938976e-02, 1.169463886737187427806439606219205e-02)


@jit
def integrate(func, a, b, divs=1, args=()):
    """Integrate 'func' w/ 'args' over the region (a, b). The region can subdived by 'divs' for better numerical accuracy"""
    skip = (b - a) / divs
    c_1 = skip / 2
    c_2 = c_1 + a
    integrator = func(c_1 * _x_kr21[0] + c_2, *args) * _w_kr21[0]
    for i in range(1, len(_x_kr21)):
        integrator += func(c_1 * _x_kr21[i] + c_2, *args) * _w_kr21[i]
    for j in range(1, divs):
        c_2 += skip
        for i in range(len(_x_kr21)):
            integrator += func(c_1 * _x_kr21[i] + c_2, *args) * _w_kr21[i]
    return c_1 * integrator


@jit
def gen_impedance(n):
    if n <= 1:
        return 3.084635 - 6.531194 * n + 8.357854 * n * n - 5.082751 * n**3 + 1.171382 * n**4
    return 504.332889 - 2641.00214 * n + 5923.699064 * n * n - 7376.355814 * n**3 + 5507.53041 * n**4 - 2463.357945 * n**5 + 610.956547 * n**6 - 64.8047 * n**7


@jit
def _gen_reflectance_coeff(t, n, m):
    Rs = ((n*cos(t)-m*sqrt(1-(n/m*sin(t))**2)) / (n*cos(t)+m*sqrt(1-(n/m*sin(t))**2)))**2
    Rp = ((n*sqrt(1-(n/m*sin(t))**2)-m*cos(t)) / (n*sqrt(1-(n/m*sin(t))**2)+m*cos(t)))**2
    Rfres = (Rs + Rp) / 2
    return 3*(1 - Rfres)*cos(t)**2*sin(t) / 2


@jit
def _gen_fluence_rate_coeff(t, n, m):
    Rs = ((n*cos(t)-m*sqrt(1-(n/m*sin(t))**2)) / (n*cos(t)+m*sqrt(1-(n/m*sin(t))**2)))**2
    Rp = ((n*sqrt(1-(n/m*sin(t))**2)-m*cos(t)) / (n*sqrt(1-(n/m*sin(t))**2)+m*cos(t)))**2
    Rfres = (Rs + Rp) / 2
    return (1 - Rfres)*cos(t)*sin(t) / 2


@jit
def gen_coeffs(n, n_ext):
    return (
        gen_impedance(n/n_ext), 
        integrate(_gen_reflectance_coeff, 0, arcsin(n_ext/n), 10, (n, n_ext)), 
        integrate(_gen_fluence_rate_coeff, 0, arcsin(n_ext/n), 10, (n, n_ext))
    )
