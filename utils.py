import numpy as np
import numba as nb
from functools import partial

jit = partial(nb.jit, nopython=True, nogil=True)
vectorize = nb.vectorize  # partial(nb.vectorize, nopython=True)

_x_kr21 = np.array([-9.956571630258080807355272806890028e-01, -9.739065285171717200779640120844521e-01, -9.301574913557082260012071800595083e-01, -8.650633666889845107320966884234930e-01, -7.808177265864168970637175783450424e-01, -6.794095682990244062343273651148736e-01, -5.627571346686046833390000992726941e-01, -4.333953941292471907992659431657842e-01, -2.943928627014601981311266031038656e-01, -1.488743389816312108848260011297200e-01, 0.0, 1.488743389816312108848260011297200e-01, 2.943928627014601981311266031038656e-01, 4.333953941292471907992659431657842e-01, 5.627571346686046833390000992726941e-01, 6.794095682990244062343273651148736e-01, 7.808177265864168970637175783450424e-01, 8.650633666889845107320966884234930e-01, 9.301574913557082260012071800595083e-01, 9.739065285171717200779640120844521e-01, 9.956571630258080807355272806890028e-01])

_w_kr21 = np.array([1.169463886737187427806439606219205e-02, 3.255816230796472747881897245938976e-02, 5.475589657435199603138130024458018e-02, 7.503967481091995276704314091619001e-02, 9.312545458369760553506546508336634e-02, 1.093871588022976418992105903258050e-01, 1.234919762620658510779581098310742e-01, 1.347092173114733259280540017717068e-01, 1.427759385770600807970942731387171e-01, 1.477391049013384913748415159720680e-01, 1.494455540029169056649364683898212e-01, 1.477391049013384913748415159720680e-01, 1.427759385770600807970942731387171e-01, 1.347092173114733259280540017717068e-01, 1.234919762620658510779581098310742e-01, 1.093871588022976418992105903258050e-01, 9.312545458369760553506546508336634e-02, 7.503967481091995276704314091619001e-02, 5.475589657435199603138130024458018e-02, 3.255816230796472747881897245938976e-02, 1.169463886737187427806439606219205e-02])


@jit
def integrate(func, a, b, divs=1, args=()):
    """Integrate 'func' w/ 'args' over the region (a, b). The region can subdived by 'divs' for better numerical accuracy"""
    skip = (b - a) / divs
    c_1 = skip / 2
    c_2 = c_1 + a
    integrator = func(c_1 * _x_kr21[0] + c_2, *args) * _w_kr21[0]
    for i in range(1, _x_kr21.shape[0]):
        integrator += func(c_1 * _x_kr21[i] + c_2, *args) * _w_kr21[i]
    for j in range(1, divs):
        c_2 += skip
        for i in range(_x_kr21.shape[0]):
            integrator += func(c_1 * _x_kr21[i] + c_2, *args) * _w_kr21[i]
    return c_1 * integrator


@jit
def gen_impedance(n):
    if n <= 1:
        return 3.084635 - 6.531194 * n + 8.357854 * n * n - 5.082751 * n**3 + 1.171382 * n**4
    return 504.332889 - 2641.00214 * n + 5923.699064 * n * n - 7376.355814 * n**3 + 5507.53041 * n**4 - 2463.357945 * n**5 + 610.956547 * n**6 - 64.8047 * n**7


@jit
def _gen_reflectance_coeff(t, n, m):
    Rs = ((n*np.cos(t)-m*np.sqrt(1-(n/m*np.sin(t))**2)) / (n*np.cos(t)+m*np.sqrt(1-(n/m*np.sin(t))**2)))**2
    Rp = ((n*np.sqrt(1-(n/m*np.sin(t))**2)-m*np.cos(t)) / (n*np.sqrt(1-(n/m*np.sin(t))**2)+m*np.cos(t)))**2
    Rfres = (Rs + Rp) / 2
    return 3*(1 - Rfres)*np.cos(t)**2*np.sin(t) / 2


@jit
def _gen_fluence_rate_coeff(t, n, m):
    Rs = ((n*np.cos(t)-m*np.sqrt(1-(n/m*np.sin(t))**2)) / (n*np.cos(t)+m*np.sqrt(1-(n/m*np.sin(t))**2)))**2
    Rp = ((n*np.sqrt(1-(n/m*np.sin(t))**2)-m*np.cos(t)) / (n*np.sqrt(1-(n/m*np.sin(t))**2)+m*np.cos(t)))**2
    Rfres = (Rs + Rp) / 2
    return (1 - Rfres)*np.cos(t)*np.sin(t) / 2


@jit
def gen_coeffs(n, n_ext):
    return (
        gen_impedance(n/n_ext), 
        integrate(_gen_reflectance_coeff, 0, np.arcsin(n_ext/n), 10, (n, n_ext)), 
        integrate(_gen_fluence_rate_coeff, 0, np.arcsin(n_ext/n), 10, (n, n_ext))
    )


_RP = np.array([-4.79443220978201773821E9,1.95617491946556577543E12,-2.49248344360967716204E14,9.70862251047306323952E15])
_RQ = np.array([4.99563147152651017219E2,1.73785401676374683123E5,4.84409658339962045305E7,1.11855537045356834862E10,2.11277520115489217587E12,3.10518229857422583814E14,3.18121955943204943306E16,1.71086294081043136091E18])
_PP = np.array([  7.96936729297347051624E-4,8.28352392107440799803E-2,1.23953371646414299388E0,5.44725003058768775090E0,8.74716500199817011941E0,5.30324038235394892183E0,9.99999999999999997821E-1,])
_PQ = np.array([9.24408810558863637013E-4,8.56288474354474431428E-2,1.25352743901058953537E0,5.47097740330417105182E0,8.76190883237069594232E0,5.30605288235394617618E0,1.00000000000000000218E0,])
_QP = np.array([-1.13663838898469149931E-2,-1.28252718670509318512E0,-1.95539544257735972385E1,-9.32060152123768231369E1,-1.77681167980488050595E2,-1.47077505154951170175E2,-5.14105326766599330220E1,-6.05014350600728481186E0,])
_QQ = np.array([  6.43178256118178023184E1,8.56430025976980587198E2,3.88240183605401609683E3,7.24046774195652478189E3,5.93072701187316984827E3,2.06209331660327847417E3,2.42005740240291393179E2,])
_DR1 = 5.783185962946784521175995758455807035071
_DR2 = 30.47126234366208639907816317502275584842
_SQ2OPI = 0.79788456080286535588
_PIO4 = .78539816339744830962


@jit
def _polevl(x, coef):
    ans = coef[0]
    for i in range(1, coef.shape[0]):
        ans = ans*x + coef[i]
    return ans


@jit
def _p1evl(x, coef):
    ans = x + coef[0]
    for i in range(1, coef.shape[0]):
        ans = ans*x + coef[i]
    return ans


@vectorize
def j0(x):
    """Bessel function of the first kind of order 0. Adapted from "Cephes Mathematical Functions Library"."""
    x = np.abs(x)
    if x > 5:
        w = 5 / x
        q = 25 / (x*x)
        p = _polevl(q, _PP) / _polevl(q, _PQ)
        q = _polevl(q, _QP) / _p1evl(q, _QQ)
        xn = x - _PIO4
        p = p * np.cos(xn) - w * q * np.sin(xn)
        return p * _SQ2OPI / np.sqrt(x)
    elif x >= 1e-5:
        z = x*x
        return (z - _DR1) * (z - _DR2) * _polevl(z, _RP)/_p1evl(z, _RQ)
    else:
        return 1 - x*x/4
